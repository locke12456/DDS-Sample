/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2015 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE
 *
 *   for full copyright notice and license terms.
 *
 */
/*
 * The contents of this file is private to SPLICE-DDS and not meant for use by
 * any application other then application code generated by SPLICE-DDS tooling.
 */

#ifndef DDS_DCPS_PRIVATE_H
#define DDS_DCPS_PRIVATE_H

#include "u_entity.h"
#include "dds_dcps.h"
#include "os_if.h"


#ifdef OSPL_BUILD_DCPSSAC
#define OS_API OS_API_EXPORT
#else
#define OS_API OS_API_IMPORT
#endif
/* !!!!!!!!NOTE From here no more includes are allowed!!!!!!! */

/* ReturnCode which indicates if an instance handle has expired.
 * This ReturnCode is only to be used internally and is converted
 * to a ReturnCode BAD_PARAMETER when returning to the user.
 */
#define DDS_RETCODE_HANDLE_EXPIRED (13)

/*
 * This function prototype is an abstract specification of the
 * deallocation operation required for all objects that can be
 * free via the DDS_free operation.
 * All classes need to implement their specific implementation
 * of this operation, if not implemented the DDS_free operation
 * will use a default implementation that only frees memory in
 * a shallow manner, if more is required the class must implement
 * its own deallocation operation. This dealloc operation is
 * passed to the object constructor and assigned to the constructed
 * object, the DDS_free operation will call the deallocator
 * operation.
 */
typedef DDS_ReturnCode_t 
(*DDS_deallocatorType)(
    DDS_Object object);

/* Generic DDS object allocation interface */

typedef void *
(*bufferAllocatorType)(
    DDS_unsigned_long len);

OS_API void *
DDS__malloc (
    DDS_deallocatorType deallocator,
    DDS_unsigned_long hl,
    DDS_unsigned_long len);

OS_API void *
DDS__header (
    void *object);

OS_API void *
DDS_alloc (
    DDS_unsigned_long l,
    DDS_deallocatorType deallocator);


/* Generic DDS_string interface */

OS_API DDS_char *
DDS_string_alloc (
    DDS_unsigned_long len);

OS_API DDS_char *
DDS_string_dup (
    const DDS_char *src);

OS_API void
DDS_string_clean (
    DDS_char **string);

OS_API void
DDS_string_replace (
    const DDS_char *src,
    DDS_char **dst);


/* Generic DDS_sequence interface */

OS_API _DDS_sequence
DDS_sequence_malloc (
    void);

OS_API void *
DDS_sequence_allocbuf (
    DDS_deallocatorType deallocator,
    DDS_unsigned_long len,
    DDS_unsigned_long count);

OS_API DDS_ReturnCode_t
DDS_sequence_free (
    _DDS_sequence sequence);

OS_API void
DDS_sequence_clean (
    _DDS_sequence sequence);

OS_API void
DDS_sequence_replacebuf (
    _DDS_sequence sequence,
    bufferAllocatorType allocbuf,
    DDS_unsigned_long count);

/**
 * Functions required by some internal tests.
 */
OS_API u_entity
DDS_Entity_get_user_entity_for_test (
    DDS_Entity _this);

OS_API u_object
DDS_Condition_get_user_object_for_test (
    DDS_Condition _this);

OS_API const DDS_char *
DDS_ReturnCode_image(
    DDS_ReturnCode_t code);

typedef void * (*DDS_allocBuffer)(DDS_unsigned_long len);
typedef void * (*DDS_registerType)(void *);
typedef v_copyin_result (*DDS_copyIn)(void *, void *, void *);
typedef void   (*DDS_copyOut)(void *, void *);

OS_API DDS_TypeSupport
DDS_TypeSupportNew (
    const DDS_char *type_name,
    const DDS_char *internal_type_name,
    const DDS_char *type_keys,
    const DDS_char **type_desc,
    int type_descArrSize,
    int type_descLength,
    const DDS_copyIn copy_in,
    const DDS_copyOut copy_out,
    const DDS_unsigned_long alloc_size,
    const DDS_allocBuffer alloc_buffer);

#undef OS_API
#endif /* DDS_DCPS_PRIVATE_H */
